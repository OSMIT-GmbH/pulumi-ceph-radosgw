// Copyright 2023, OSMIT GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package provider

import (
	"errors"
	"fmt"
	"strings"

	"github.com/ceph/go-ceph/rgw/admin"
	"github.com/pulumi/pulumi-go-provider/infer"
	"github.com/pulumi/pulumi/sdk/v3/go/common/diag"

	p "github.com/pulumi/pulumi-go-provider"
)

// Each resource has a controlling struct.
// Resource behavior is determined by implementing methods on the controlling struct.
// The `Create` method is mandatory, but other methods are optional.
// - Check: Remap inputs before they are typed.
// - Diff: Change how instances of a resource are compared.
// - Update: Mutate a resource in place.
// - Read: Get the state of a resource from the backing provider.
// - Delete: Custom logic when the resource is deleted.
// - Annotate: Describe fields and set defaults for a resource.
// - WireDependencies: Control how outputs and secrets flows through values.
type Key struct{}

// Each resource has in input struct, defining what arguments it accepts.
type KeyArgs struct {
	// User id (parent)
	UserID string `pulumi:"userId"`
	// Sub user name
	SubUserName string `pulumi:"subUserName,optional"`

	AccessKey string `pulumi:"accessKey,optional"`
	SecretKey string `pulumi:"secretKey,optional"`
	KeyType   string `pulumi:"keyType,optional"`
}

func (m *KeyArgs) Annotate(a infer.Annotator) {
	a.Describe(&m.UserID, "User-ID of 'parent' user")
	a.Describe(&m.SubUserName, "Name of sub-user (optional)")
	a.Describe(&m.AccessKey, "The access key")
	a.Describe(&m.SecretKey, "The secret key")
	a.Describe(&m.KeyType, "key type - either 's3' or 'swift'")
}

// Each resource has a state, describing the fields that exist on the created resource.
type KeyState struct {
	// It is generally a good idea to embed args in outputs, but it isn't strictly necessary.
	KeyArgs
	// this config element was assimilated...
	// Required: true
	Assimilated bool `pulumi:"_assimilated"`
}

// All resources must implement Create at a minumum.
func (thiz *Key) Create(ctx p.Context, name string, input KeyArgs, preview bool) (string, KeyState, error) {
	// bail out now when we are in preview mode
	if preview {
		return IdPreviewPrefix + name, KeyState{
			KeyArgs: input,
		}, nil
	}

	retErr := func(err error) (string, KeyState, error) {
		return "", KeyState{KeyArgs: input}, err
	}

	ce, _, err := initClient(ctx)
	if err != nil {
		return retErr(err)
	}

	// we have to get current keys to find new / autogenerated key
	user, err := ce.client.GetUser(ctx, admin.User{ID: input.UserID})
	if err != nil {
		return retErr(err)
	}
	seen := make(map[string]bool, len(user.Keys))
	for _, key := range user.Keys {
		seen[key.AccessKey] = true
	}

	newKey := admin.UserKeySpec{
		User:    input.UserID,
		UID:     input.UserID,
		SubUser: input.SubUserName,

		KeyType: ifte[string](input.KeyType != "", input.KeyType, "s3"),
	}

	if input.AccessKey == "" || input.SecretKey == "" {
		generateKey := true
		newKey.GenerateKey = &generateKey
	} else {
		newKey.AccessKey = input.AccessKey
		newKey.SecretKey = input.SecretKey
	}

	keys, err := ce.client.CreateKey(ctx, newKey)
	if err != nil {
		return retErr(err)
	}

	state := KeyState{KeyArgs: input, Assimilated: false}
	for _, key := range *keys {
		if seen[key.AccessKey] {
			continue
		}

		parts := strings.SplitN(key.User, ":", 2)
		if len(parts) == 2 {
			state.UserID = parts[0]
			state.SubUserName = parts[1]
		} else {
			state.UserID = key.User
		}

		state.KeyType = key.KeyType
		state.AccessKey = key.AccessKey
		state.SecretKey = key.SecretKey
		break
	}

	id := fmt.Sprintf("%s:%s:%s", input.KeyType, input.UserID, input.SubUserName)
	return id, state, err
}

func (*Key) Diff(ctx p.Context, id string, olds KeyState, news KeyArgs) (p.DiffResponse, error) {
	diff := map[string]p.PropertyDiff{}
	if news.UserID != olds.UserID {
		diff["userId"] = p.PropertyDiff{Kind: p.UpdateReplace}
	}
	if news.SubUserName != olds.SubUserName {
		diff["subUserName"] = p.PropertyDiff{Kind: p.UpdateReplace}
	}
	if news.KeyType != olds.KeyType {
		diff["keyType"] = p.PropertyDiff{Kind: p.UpdateReplace}
	}
	if news.AccessKey != olds.AccessKey {
		diff["accessKey"] = p.PropertyDiff{Kind: p.UpdateReplace}
	}
	if news.SecretKey != olds.SecretKey {
		diff["secretKey"] = p.PropertyDiff{Kind: p.Update}
	}
	// if news.Email != olds.Email {
	// 	diff["email"] = p.PropertyDiff{Kind: p.Update}
	// }
	//diffWalk(ctx, diff, "tags", reflect.ValueOf(olds.Tags), reflect.ValueOf(news.Tags))

	if len(diff) > 0 {
		ctx.Log(diag.Info, fmt.Sprintf("DIFF on Key %s: Found %d diffs: %v", id, len(diff), diff))
	}
	return p.DiffResponse{
		DeleteBeforeReplace: true,
		HasChanges:          len(diff) > 0,
		DetailedDiff:        diff,
	}, nil
}

func (*Key) Read(ctx p.Context, id string, inputs KeyArgs, state KeyState) (string, KeyArgs, KeyState, error) {
	ctx.Logf(diag.Info, "READ on %s[%s]: Keeping as this object was assimilated!", "Key", id)
	parts := strings.SplitN(id, ":", 2)
	if len(parts) != 2 {
		return id, inputs, state, errors.New(fmt.Sprintf("Error splitting up id `%s` into parts", id))
	}

	ce, _, err := initClient(ctx)
	if err != nil {
		return id, inputs, state, err
	}
	user, err := ce.client.GetUser(ctx, admin.User{ID: parts[0]})
	if err != nil {
		return id, inputs, state, err
	}
	expectedUser := state.UserID
	if state.SubUserName != "" {
		expectedUser = state.UserID + ":" + state.SubUserName
	}

	var found bool
	var matchingKey admin.UserKeySpec
	for _, key := range user.Keys {
		if key.User == expectedUser && key.AccessKey == state.AccessKey && key.SecretKey == state.SecretKey {
			found = true
			matchingKey = key
			break
		}
	}

	if !found {
		return id, inputs, state, errors.New(fmt.Sprintf("Could not find Key `%s` within user `%s`", parts[1], parts[0]))
	}
	ret := KeyState{KeyArgs: inputs, Assimilated: state.Assimilated}
	ret.AccessKey = matchingKey.AccessKey
	return id, inputs, ret, err
}

// func (*Key) Update(ctx p.Context, id string, olds KeyState, news KeyArgs, preview bool) (KeyState, error) {
// 	user, Key, err := KeyArgsToAPI(news)
// 	if err != nil {
// 		return olds, err
// 	}
// 	// bail out now when we are in preview mode
// 	if preview {
// 		return ToKeyState(news, olds), nil
// 	}
// 	ce, _, err := initClient(ctx)
// 	if err != nil {
// 		return olds, err
// 	}

// 	err = ce.client.ModifyKey(ctx, user, Key)
// 	if err != nil {
// 		return olds, err
// 	}

// 	readState, err := APItoKeyArgs(Key, olds.KeyArgs)
// 	return ToKeyState(readState, olds), err
// }

func (*Key) Delete(ctx p.Context, id string, state KeyState) error {
	ctx.Logf(diag.Info, "DELETE on %s[%s]: Keeping as this object was assimilated!", "Key", id)
	ce, c, err := initClient(ctx)
	if err != nil {
		return err
	}
	if state.Assimilated && !c.deleteAssimilated {
		ctx.Logf(diag.Info, "DELETE on %s[%s]: Keeping as this object was assimilated!", "Key", id)
		return nil
	}

	return ce.client.RemoveKey(ctx, admin.UserKeySpec{
		UID:       state.UserID,
		SubUser:   state.SubUserName,
		AccessKey: state.AccessKey,
		KeyType:   state.KeyType,
	})
}
